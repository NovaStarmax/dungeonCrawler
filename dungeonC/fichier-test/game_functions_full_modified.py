
import random
import time
from entities import Player, Monster, Weapon, generateItem, generateWeapon
from combat import fight, UseItem
import keyboard
import pygame

# Initialise pygame
pygame.init()

# Chargez la musique de fond
pygame.mixer.music.load("intro.mp3")

# D√©marrez la musique en boucle
pygame.mixer.music.play(-1)

def main_menu():
    print("Bienvenue dans le jeu Dungeon Crawler !")
    print("1. D√©marrer le jeu")
    print("2. Quitter")
    choice = input("Entrez votre choix : ")
    if choice == "1":
        start_game()
    elif choice == "2":
        exit()
    else:
        print("Choix invalide")
        main_menu()

# Nouvelle structure pour g√©rer la g√©n√©ration de la carte et la boucle de salles
class Dungeon:
    def __init__(self):
        self.rooms = [] # Liste des salles g√©n√©r√©es
        self.current_room = 0 # Index de la salle actuelle
        self.key_obtained = False # Si le joueur a obtenu la cl√©

    def generate_rooms(self):
        # G√©n√©ration de 3 salles avec des dimensions al√©atoires entre 10x10 et 30x30
        for _ in range(3):
            size = random.randint(10, 30)
            self.rooms.append(self.generate_map(size))

    def generate_map(self, size):
        # Cr√©ation de la carte d'une salle
        map = [["  " for _ in range(size)] for _ in range(size)]
        map[1][1] = "üè≥Ô∏è" # Point de d√©part
        map[size - 2][size - 2] = "üö™" # Sortie
        return map

    def display_room(self):
        # Affichage de la salle actuelle
        for row in self.rooms[self.current_room]:
            print(' '.join(row))

    def next_room(self):
        # Passage √† la salle suivante, avec retour √† la 1√®re apr√®s la 3√®me
        self.current_room = (self.current_room + 1) % 3
        if self.current_room == 0 and not self.key_obtained:
            print("Vous avez obtenu une cl√© sp√©ciale !")
            self.key_obtained = True

# Remplacement de la fonction start_game par une version adapt√©e √† la nouvelle structure de Dungeon
def start_game():
    dungeon = Dungeon()
    dungeon.generate_rooms()
    # Exemple de logique pour avancer √† travers les salles et int√©grer la salle du boss
    # Cette partie sera d√©velopp√©e plus en d√©tail lors de l'impl√©mentation compl√®te


# Import de la biblioth√®que n√©cessaire pour d√©tecter les pressions de touches
import keyboard

class Dungeon:
    # Ajout d'une m√©thode pour afficher les stats et objets du joueur
    def display_player_stats(self, player):
        print("\nStats du Joueur:")
        print(f"Vie: {player.health} / {player.max_health}")
        print(f"Attaque: {player.attack}")
        print(f"D√©fense: {player.defense}")
        print("Objets:", ", ".join([item.name for item in player.inventory]))
        print("")  # Ligne vide pour s√©parer les stats des autres outputs

    # Modification de la m√©thode next_room pour int√©grer le d√©placement des ennemis
    def next_room(self, player):
        # Passage √† la salle suivante avec logique de d√©placement des ennemis
        super().next_room()  # Appel de la m√©thode de base pour changer de salle
        
        # D√©placement al√©atoire des ennemis
        for enemy in self.rooms[self.current_room].enemies:
            enemy.move_randomly(self.rooms[self.current_room])

# Ajout d'une fonction pour g√©rer les pressions de touches et afficher les stats du joueur
def handle_key_presses(player):
    if keyboard.is_pressed('s'):  # Si la touche 's' est press√©e, afficher les stats du joueur
        dungeon.display_player_stats(player)

# Exemple simplifi√© de la m√©thode pour d√©placer un ennemi al√©atoirement
# √Ä int√©grer dans la classe des ennemis
def move_randomly(self, room):
    # Logique de d√©placement al√©atoire, en veillant √† ne pas traverser les murs
    directions = ['up', 'down', 'left', 'right']
    direction = random.choice(directions)
    # Impl√©menter la logique de d√©placement ici, en prenant en compte les limites de la carte et les murs
